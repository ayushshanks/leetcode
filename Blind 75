// Array & Hashmap

var twoSum = function (nums, target) { // Find two numbers which are two-sum of target in nums                      
    const map = new Map(); // create a new map
    for (let i = 0; i < nums.length; i++) { // now iterate over nums
        const complement = target - nums[i] // find complement of target to current
        if (map.has(complement)) { // if there's complement in map
            return [map.get(complement), i] // return complement and current index
        }
        map.set(nums[i], i) // map current number to current index otherwise
    }
};

class EncodeDecode { // Encode and decode string
    encode(strs) {
        let encoded = ''
        for(let str of strs){
            encoded += str.length + "#" + str
        }
        return encoded;
    }
    decode(str) {
        let decoded = []
        let i = 0;
        while ( i < str.length){ //while i is in bound
            let j = str.indexOf('#', i) //find delimeter
            let length = parseInt(str.slice(i,j)); // find length
            i = j+1; // start from the beginning of string
            decoded.push(str.slice(i,i+length)) // push into str
            i += length // jump to next string
        }
        return decoded
    }
}

function productExceptSelf(nums){
    const n = nums.length;
    const result  = Array(n).fill(1)
    let leftProduct = 1;
    for (let i = 0; i<n; i++){
        result[i] = leftProduct;
        leftProduct *= nums[i]
    }
    let rightProduct = 1
    for (let i=n-1; i>=0; i--){
        result[i] *= rightProduct;
        rightProduct *= nums[i]
    }
    return result
}

var longestConsecutive = function(nums) {   // longest coonsecutive subsequence
    if (nums.length === 0) return 0
    let longest = 0;
    let numSet = new Set(nums)
    for (let num of nums){
        if (!numSet.has(num-1)){
            let currentStreak = 1;
            let currentNum = num
            while ( numSet.has(currentNum+1) ){
                currentNum++;
                currentStreak++;
            }
            longest = Math.max(longest, currentStreak)
        }
    }
    return longest
};

// Two pointer

var isPalindrome = function(s) { // Check is if a string is a palindrome
    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g,'');
    return cleaned === cleaned.split('').reverse().join('');
};

